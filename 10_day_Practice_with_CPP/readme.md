* day04:

    - const可以修饰变量, 引用, 指针,函数参数,成员函数, 成员变量

        相比于宏:const 会做类型检查, 可以调试,

        - 1. 常类型

            常类型的对象必须进行初始化，而且不能被更新。 
            eg: const int NUM = 100;

        - 2. 常引用：const int& p [常量指针类似]

            常引用被引用的对象不能被更新。 const 类型说明符 &引用名 

        - 3. 常对象：A const a;

            必须进行初始化,不能被更新。 类名 const 对象名 

        - 4. 常数组：数组元素不能被更新。 类型说明符 const 数组名[大小]... 

        - 5. 修饰成员函数时,本质时修饰"this"指针,因此,不能改变成员变量

        - PS:

            1. 常量指针 ： 只能读取所指内存中的数据不能修改（指向常量的指针）: 内存中的内容是一个常量，不可以改

            const int *p | int const *p

            2. 指针常量 ： 指向的位置不能改变，即指针本身是一个常量，但是所指向内存的数据是可以修改的 ： 指针是一个常量，不可改

            int* const p = &a; 

    - 友元friend：

        - 1. 友元函数：类友元函数是非成员函数，但访问权限与类的成员函数相同

            在类中声明该函数，函数前加上friend关键字
            eg:  重载 << 运算符
                void operator<<(ostream& os, ...)

        - 2. 友元类：

            友元类的所有方法都可以访问原始类的私有成员和保护成员

        - 3.友元成员函数：

* day05:

    - 1. 基类base与派生类derive的对象关系:

        derive对象赋给base对象          反之不可
        derive地址赋给base类指针        反之不可
        derive对象初始化base对象的引用   反之不可
    

    - 2.析构函数|构造函数

        - 1. 类对象成员的构造 先构造成员 再构造自身（调用构造函数） 
        - 2. 派生类构造函数 派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对 象时，派生类的构造函数除了要负责本类成员的初始化外

         还要调用 基类和成员对象的构造函数，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。

        - 3. 派生类只能采用构造函数 初始化列表的方式 向基类或成员对象的构造函数传递参数，形式如下：

            派生类构造函数名(参数表):基类构造函数名(参数表),成员对象名1(参数表),…{ //…… }

        - 4. 构造函数和析构函数调用次序 派生类对象的构造

                先构造基类 -> 再构造成员 -> 最后构造自身（调用构造函数）

        - 5. 基类构造顺序由派生层次决定：

            最远的基类最先构造 成员构造顺序和定义顺序符合 
            析构函数的析构顺序与构造相反

            先构造基类 -> 然后构造成员变量       ->  最后构造自己
            先析构自己 -> 在析构成员变量(若是类) ->  最后析构基类
            成员变量按声明顺序进行初始化

    - 3.三种继承方式:

        - 1. 公有继承

            - 1.1 派生类不可以访问基类的 private 成员
            - 1.2 派生类可以访问基类的 protected 成员
            - 1.3 派生类可以访问基类的 public 成员

        - 2. 保护继承:
            - 2.1 保护继承使得基类的public 成员变为了protected, 派生类可以访问, 但是派生类对象不能访问
        - 3. 私有继承:
            - 3.1 私有继承, 使得基类的成员都由了private所有, 因此派生类不可访问基类的任何成员

* day06: 
    -  1. 虚函数 : virtual  函数名 (参数列表);
            - 概念: 
            - 意义:
            - 特征:
                1. 基类指针指向派生类的对象时,通过该指针访问其虚函数将调用派生类的版本
                2. 一旦将某个成员函数声明为虚函数后,它在继承体系中永远时虚函数
                3. 派生类中的虚函数要保持其虚特征,必须与基类虚函数的函数原型完全相同,否在就是重载函数.

              # 4. 只有类的非静态成员才能被定义为虚函数,类的构造函数和静态成员函数不能被定义为虚函数.因为虚函数在继承层次结构中才能发送作用,而构造函数和静态成员是不能被继承的.[??]

                5. 内联函数也不能是虚函数,因为内联函数采用的是静态联编方法是,[即使虚函数在类中定义了,但是编译器还是会将它视为非内联]

              # 6. 基类的析构函数几乎总是虚的析构函数

            - # 纯虚函数[pure_funtion]: 只声明原型,而没有代码实现.
                1. 使用角度 : 占用手段[place-holder]
                2. 接口定义
                3. 纯虚函数在其派生类实现

            - # 抽象类[abstract-class]: 包含一个或多个纯虚函数的类
                1. 不能用抽象类实例化对象,但是可以定义抽象类指针或引用
                2. 在抽象类的派生类中实现其虚函数
                3. 抽象类只能作为其他类的基类
                4. 派生类只继承抽象类,而没有实现抽象类的纯虚函数,那么派生类也是一个抽象类

                

                

                

               

            + 原理:
                - 编译器 给每个对象新增了一个[隐藏的成员],该成员是一个[指向函数地址数组]的指针, 该数组就是虚函数表[virtual_futntion_table|vtbl], vtbl中存储了类对象中的每一个虚函数的地址 

                - base 有一个 指针 指向 基类的base的vtbl,
                - derive 也有一个执行指向派生类的vtbl ,若干derive新增虚函数,则添加到自己的vtbl,若重新了基类的虚函数,则用新的函数地址覆盖原来地址,没有变化则与基类的vtbl相同.

                -  [无论类中虚函数的个数,编译器都只会新增|一个地址成员(指针)|]只是大小不同
            - virtual 关键字:

                告诉编译器,该函数采用动态联编的方式编译

            - 纯虚函数:

    -  2. 多态[polymorphism]:
            - 概念 : 在同一类或继承体系的基类与派生类总,用相同的函数实现不同的功能
            - 静态绑定|静态联编[static_binding]: 在编译期间绑定, 通过对象调用

              静态绑定是[c++默认选择]

                - 静态多态: 函数重载[overload]

                    eg: C++模板

            - 动态绑定|动态联编[dynamic_binding]: 在运行期间绑定, 通过地址绑定
                - 动态多态: 虚函数 [virtual]

            - 效率与概念:
                - a. 为了能够在运行时进行决策绑定,必须使用某些方法来跟踪基类指针或引用执行的对象,从而增加了开销.

                    若 class 不作为基类|派生类不重定义基类的任何函数,也就不需要动态绑定了,这两种情况下使用静态绑定更为合理[效率更高] 
